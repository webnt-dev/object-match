{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.mts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @todo add $exists\n * @todo rewrite objectTemplateIntersection - too complex\n */\n\n/**\n * Type represents JSON valid scalar variable\n */\ntype JSONScalar = string | number | boolean | null;\n\n/**\n * Type represents JSON valid object\n */\ntype JSONObject = { [property: string]: JSONData };\n\n/**\n * Type represents any JSON valid value\n */\ntype JSONData = JSONScalar | JSONArray | JSONObject;\n\n/**\n * Type represents JSON valid array\n */\ntype JSONArray = JSONData[];\n\n/**\n * Type represents JSON valid value or undefined, generic type\n */\ntype Optional<T> = T | undefined;\n\n/**\n * Type represents template matching function type\n */\ntype PatternMatchingFunction = (value: JSONData, template: JSONData) => Optional<JSONData>;\n\n/**\n * Dictionary of all templete matching functions\n */\nconst patternFunctions: Record<string, PatternMatchingFunction> = {};\n\nfunction supportedType(value: any): boolean {\n\tconst valueType = typeof value;\n\tconst result = ['object', 'boolean', 'number', 'string'].includes(valueType);\n\treturn result;\n}\n\nfunction isScalar(value: JSONData): value is JSONScalar {\n\tconst result = value === null || ['boolean', 'number', 'string'].includes(typeof value);\n\treturn result;\n}\n\nfunction isJSONObject(value: JSONData): value is JSONObject {\n\tconst result = (typeof value === 'object') &&\n\t\t(value !== null) &&\n\t\t(!Array.isArray(value));\n\treturn result;\n}\n\nfunction isNumber(value: JSONData): value is number {\n\tconst result = (typeof value === 'number');\n\treturn result;\n}\n\nfunction isString(value: JSONData): value is string {\n\tconst result = (typeof value === 'string');\n\treturn result;\n}\n\n/** *************\n* Exact comparison functions\n** ************ */\n\nfunction numberCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (typeof target === 'number');\n\treturn result;\n}\n\nfunction stringCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (typeof target === 'string');\n\treturn result;\n}\n\nfunction booleanCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (typeof target === 'boolean');\n\treturn result;\n}\n\nfunction nullCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (target === null);\n\treturn result;\n}\n\nfunction arrayCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = Array.isArray(source) &&\n\tArray.isArray(target) &&\n\t(source.length === target.length) &&\n\ttarget.every((_, index) => compareValues(source[index], target[index]));\n\treturn result;\n}\n\nfunction compareValues(source: JSONData, target: JSONData): boolean {\n\tconst targetType = typeof target;\n\tlet result;\n\tif (target === null) {\n\t\tresult = nullCompare(source, target);\n\t}\n\tswitch (targetType) {\n\t\tcase 'boolean': result = booleanCompare(source, target as boolean); break;\n\t\tcase 'number': result = numberCompare(source, target as number); break;\n\t\tcase 'object': result = Array.isArray(target) ? arrayCompare(source, target as JSONData[]) : objectCompare(source as JSONObject, target as JSONObject); break;\n\t\tcase 'string': result = stringCompare(source, target as string); break;\n\t\tdefault: throw new Error(`compareValues: Unsuported type ${targetType}`);\n\t}\n\treturn result;\n}\n\n/**\n * Function matches two objects, if those are the same.\n * Function does not do pattern matching, but exact comparison\n *\n * @param {JSONObject|null} source - object to test\n * @param {JSONObject|null} target - object to test agains\n * @returns { boolean } true if value is the same as target\n */\nfunction objectCompare(source: JSONObject | null, target: JSONObject | null): boolean {\n\tlet result = false;\n\tif (target === null) {\n\t\tresult = nullCompare(source, target);\n\t} else if (source === null) {\n\t\tresult = nullCompare(source, target);\n\t} else {\n\t\tconst keys = Object.keys(target);\n\t\tif (Object.keys(source).length === keys.length) {\n\t\t\tresult = keys.every((key: string) => compareValues(source[key], target[key]));\n\t\t}\n\t}\n\treturn result;\n}\n\n/** *************\n* types functions\n** ************ */\n\nfunction numberIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = numberCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction stringIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = stringCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction nullIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = nullCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction booleanIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = booleanCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction scalarIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (template === null) {\n\t\tresult = nullIntersection(value, template);\n\t} else {\n\t\tconst templateType = typeof template;\n\t\tswitch (typeof template) {\n\t\t\tcase 'number': result = numberIntersection(value, template); break;\n\t\t\tcase 'string': result = stringIntersection(value, template); break;\n\t\t\tcase 'boolean': result = booleanIntersection(value, template); break;\n\t\t\tdefault: throw new Error(`scalarIntersection: Unsuported type ${templateType}`);\n\t\t}\n\t}\n\treturn result;\n\n}\n\nfunction arrayIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\t// const result = arrayCompare(value, template) ? template : undefined;\n\n\tconst result = Array.isArray(value) &&\n\tArray.isArray(template) &&\n\t(value.length === template.length) &&\n\ttemplate.every((_, index) => valueIntersection(value[index], template[index]));\n\treturn result ? template : undefined;\n}\n\n/**\n * Function provides recursive pattern matching.\n * If template is scalar, function just compares values\n * If template is array, function traverse the array and tries to apply all items as patterns to value\n * If template is object, function traverse the object and tries to apply all properties as patterns to value\n *\n * @param {JSONObject} source - object to test\n * @param {JSONObject} template - pattern to test agains\n * @returns { boolean } true if value matches template\n */\nfunction valueIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\n\t// scalar template\n\tif (isScalar(template)) {\n\t\tresult = scalarIntersection(value, template);\n\t} else if (Array.isArray(template)) { \t// array template\n\t\tresult = arrayIntersection(value, template);\n\t} else { // object template\n\t\tresult = objectTemplate2any(value, template);\n\t}\n\t// debugger;\n\treturn result;\n}\n\n/** *************\n* pattern functions\n** ************ */\n\n// equality - could be missing\nfunction $eq(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = valueIntersection(value, template);\n\t// debugger;\n\treturn result;\n}\n\n// negation\nfunction $not(value: JSONData, template: JSONData): Optional<JSONData> {\n\t// debugger;\n\tconst result = valueIntersection(value, template) === undefined ? template : undefined;\n\n\treturn result;\n}\n\n// value in template\nfunction $in(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$in: expects array, ${template} given`);\n\t}\n\tconst found = template.find((_, index) => valueIntersection(value, template[index]));\n\treturn found !== undefined ? template : undefined;\n}\n\n// number of keys in object, number of items in array\nfunction $size(value: JSONData, template: JSONData): Optional<JSONData> {\n\n\tlet size;\n\tif (Array.isArray(value)) {\n\t\tsize = value.length;\n\t} else if (isJSONObject(value)) {\n\t\tsize = Object.keys(value).length;\n\t}\n\tif (size !== undefined) {\n\t\tconst result = valueIntersection(size, template);\n\t\treturn result;\n\t}\n\n\treturn undefined;\n}\n\n// template in value\nfunction $contains(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(value)) {\n\t\tthrow new Error(`$contains: expects array, ${value} given`);\n\t}\n\tconst found = value.find((_, index) => valueIntersection(value[index], template));\n\treturn found !== undefined ? template : undefined;\n}\n\n// arrays intersection\nfunction $intersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template) || !Array.isArray(value)) {\n\t\tthrow new Error(`$intersection: expects array, ${template} , ${value} given`);\n\t}\n\tconst found = value.find((_, indexV) => template.find((__, index) => valueIntersection(value[indexV], template[index])));\n\n\treturn found !== undefined ? template : undefined;\n}\n\n// value is subset on template\nfunction $subsetOf(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template) || !Array.isArray(value)) {\n\t\tthrow new Error(`$subsetOf: expects array, ${template} , ${value} given`);\n\t}\n\tconst found = value.every((_, indexV) => template.find((__, index) => valueIntersection(value[indexV], template[index])));\n\treturn found ? template : undefined;\n}\n\n// template is subset on value\nfunction $supersetOf(value: JSONData, template: JSONData): Optional<JSONData> {\n\n\tif (!Array.isArray(template) || !Array.isArray(value)) {\n\t\tthrow new Error(`$supersetOf: expects array, ${template} , ${value} given`);\n\t}\n\n\tconst found = template.every((_, indexV) => {\n\t\tconst resultT = value.find((__, index) => {\n\t\t\tconst resultV = valueIntersection(value[index], template[indexV]);\n\t\t\treturn resultV !== undefined;\n\t\t});\n\t\treturn resultT !== undefined;\n\t});\n\treturn found ? template : undefined;\n}\n\nfunction canCompare(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (!isNumber(value) && !isString(value)) {\n\t\tresult = false;\n\t} else if (!isNumber(template) && !isString(template)) {\n\t\tresult = false;\n\t} else if (typeof value !== typeof template) {\n\t\tresult = false;\n\t} else {\n\t\tresult = true;\n\t}\n\n\treturn result;\n}\n\n// value is grater than template\nfunction $gt(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value > template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// value is grater or equal than template\nfunction $gte(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value >= template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// value is lower than template\nfunction $lt(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value < template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// value is lower or equal than template\nfunction $lte(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value <= template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// all items in template applies to value\nfunction $and(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$and: template must be array, ${template} given`);\n\t}\n\n\tconst result = template.every((_, index) => valueIntersection(value, template[index]));\n\n\treturn result ? template : undefined;\n}\n\n// at least one items in template applies to value\nfunction $or(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$or: template must be array, ${template} given`);\n\t}\n\n\tconst result = template.find((_, index) => valueIntersection(value, template[index]));\n\n\treturn result ? template : undefined;\n}\n\n// not any items in template applies to value\nfunction $none(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$none: template must be array, ${template} given`);\n\t}\n\n\tconst result = template.find((_, index) => valueIntersection(value, template[index]));\n\n\treturn result ? undefined : template;\n}\n\nfunction $hasKey(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (typeof template !== 'string') {\n\t\tthrow new Error('$hasKey: template must be string');\n\t}\n\tif (isJSONObject(value)) {\n\t\treturn Object.hasOwn(value, template) ? template : undefined;\n\t}\n\treturn undefined;\n\n}\n\npatternFunctions.$eq = $eq; // any, any\npatternFunctions.$neq = $not; // any, any\npatternFunctions.$not = $not; // any, any\npatternFunctions.$in = $in; // any, array\npatternFunctions.$is = $eq; // any, any\npatternFunctions.$size = $size; // array | object, number\npatternFunctions.$contains = $contains; // array , any\npatternFunctions.$intersection = $intersection; // array , array\n// patternFunctions.$intersectionSize = $intersectionSize; // array , array\npatternFunctions.$subsetOf = $subsetOf; // array , array\npatternFunctions.$supersetOf = $supersetOf; // array , array\npatternFunctions.$gt = $gt; // string | number , string | number\npatternFunctions.$gte = $gte; // string | number , string | number\npatternFunctions.$lt = $lt; // string | number , string | number\npatternFunctions.$lte = $lte; // string | number , string | number\npatternFunctions.$and = $and; // any , array\npatternFunctions.$or = $or; // any , array\npatternFunctions.$none = $none; // any , array\npatternFunctions.$hasKey = $hasKey; // object , string\n\nfunction patternIntersection(key: string, value: Optional<JSONData>, template: JSONData): Optional<JSONData> {\n\tlet result;\n\n\tif (value === undefined) {\n\t\tthrow new Error(`patternIntersection: Value cannot be undefined here for key: ${key}`); // this should never happen\n\t} else if (Object.hasOwn(patternFunctions, key)) {\n\t\tresult = patternFunctions[key].call(null, value, template);\n\t} else {\n\t\tthrow new Error(`patternIntersection: Unsupported matching pattern ${key}`);\n\t}\n\n\treturn result;\n}\n\nfunction objectTemplate2Scalar(source: JSONScalar, template: JSONObject): Optional<JSONObject> {\n\t// all template keys must be functions and they must all match against source\n\n\tif (!isJSONObject(template)) {\n\t\tthrow new Error('objectTemplate2Scalar: template must be object');\n\t}\n\n\tconst templateKeys = Object.keys(template);\n\n\tconst areMatching = templateKeys.every((key: string) => {\n\t\tif (!supportedType(template[key])) {\n\t\t\tthrow new Error(`objectTemplate2Scalar: unsupported value (type) in template ${template[key]}`);\n\t\t}\n\t\tif (key.startsWith('$')) {\n\t\t\tconst match = patternIntersection(key, source, template[key]);\n\t\t\treturn match !== undefined;\n\t\t}\n\t\treturn false;\n\t});\n\n\treturn areMatching ? template : undefined;\n}\n\nfunction objectTemplate2Object(source: JSONObject, template: JSONObject): Optional<JSONObject> {\n\tif (!isJSONObject(template)) {\n\t\tthrow new Error('objectTemplate2Object: template must be object');\n\t}\n\n\tconst templateKeys = Object.keys(template);\n\n\tconst areMatching = templateKeys.every((key: string) => {\n\t\tif (!supportedType(template[key])) {\n\t\t\tthrow new Error(`objectTemplate2Object: unsupported value (type) in template ${template[key]}`);\n\t\t}\n\n\t\tif (Object.hasOwn(source, key)) {\n\t\t\tconst match = valueIntersection(source[key], template[key]);\n\t\t\treturn match !== undefined;\n\t\t}\n\n\t\tif (key.startsWith('$')) {\n\t\t\tconst match = patternIntersection(key, source, template[key]);\n\t\t\treturn match !== undefined;\n\t\t}\n\t\treturn false;\n\t});\n\n\treturn areMatching ? template : undefined;\n}\n\nfunction objectTemplate2Array(source: JSONArray, template: JSONObject): Optional<JSONObject> {\n\tif (!isJSONObject(template)) {\n\t\tthrow new Error('objectTemplate2Array: template must be object');\n\t}\n\n\tconst templateKeys = Object.keys(template);\n\n\tconst areMatching = templateKeys.every((key: string) => {\n\t\tif (!supportedType(template[key])) {\n\t\t\tthrow new Error(`objectTemplate2Array: unsupported value (type) in template ${template[key]}`);\n\t\t}\n\n\t\tif (key.startsWith('$')) {\n\t\t\tconst match = patternIntersection(key, source, template[key]);\n\t\t\treturn match !== undefined;\n\t\t}\n\t\treturn false;\n\t});\n\n\treturn areMatching ? template : undefined;\n}\n\nfunction objectTemplate2any(source: JSONData, template: JSONData): Optional<JSONObject> {\n\n\t// debugger;\n\tif (\n\t\t(typeof template !== 'object') ||\n\t\t(template === null) ||\n\t\t(Array.isArray(template)) ||\n\t\tfalse\n\t) {\n\t\tthrow new Error('objectTemplate2any: template must be non-null, non-array objects');\n\t}\n\n\tlet result;\n\n\tif (isScalar(source)) {\n\t\tresult = objectTemplate2Scalar(source, template);\n\t} else if (isJSONObject(source)) {\n\t\tresult = objectTemplate2Object(source, template);\n\t} else if (Array.isArray(source)) {\n\t\tresult = objectTemplate2Array(source, template);\n\t}\n\n\treturn result;\n}\n\n\nfunction objectIntersection(source: JSONData, template: JSONData): JSONObject | null {\n\t// debugger;\n\tif (\n\t\t(typeof source !== 'object') ||\n\t\t(typeof template !== 'object') ||\n\t\t(source === null) ||\n\t\t(template === null) ||\n\t\t(Array.isArray(source)) ||\n\t\t(Array.isArray(template)) ||\n\t\tfalse\n\t) {\n\t\tthrow new Error('objectIntersection: source and template must be non-null, non-array objects');\n\t}\n\tconst result = objectTemplate2any(source, template);\n\treturn result === undefined ? null : result;\n\n}\n\n/**\n * Main function for object matching\n *\n * @param {JSONObject} source - object to test\n * @param {JSONObject} template - pattern to test agains\n * @returns { boolean } true if value matches template\n */\nfunction objectMatch(source: JSONObject, template: JSONObject): boolean {\n\t// debugger;\n\treturn objectIntersection(source, template) !== null;\n}\n\nexport {\n\tJSONScalar, JSONObject, JSONData, JSONArray, Optional, PatternMatchingFunction,\n\tobjectIntersection, objectMatch, valueIntersection,\n\tobjectCompare,\n\n\tpatternFunctions,\n};\n"]}