{"version":3,"file":"index.mjs","sourceRoot":"","sources":["../src/index.mts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @todo add $exists\n * @todo rewrite objectTemplateIntersection - too complex\n */\n\n/**\n * Type represents JSON valid scalar variable\n */\ntype JSONScalar = string | number | boolean | null;\n\n/**\n * Type represents JSON valid object\n */\ntype JSONObject = { [property: string]: JSONData };\n\n/**\n * Type represents any JSON valid value\n */\ntype JSONData = JSONScalar | JSONArray | JSONObject;\n\n/**\n * Type represents JSON valid array\n */\ntype JSONArray = JSONData[];\n\n/**\n * Type represents JSON valid value or undefined, generic type\n */\ntype Optional<T> = T | undefined;\n\n/**\n * Type represents template matching function type\n */\ntype PatternMatchingFunction = (value: JSONData, template: JSONData) => Optional<JSONData>;\n\n/**\n * Dictionary of all templete matching functions\n */\nconst patternFunctions: Record<string, PatternMatchingFunction> = {};\n\nfunction supportedType(value: any): boolean {\n\tconst valueType = typeof value;\n\tconst result = ['object', 'boolean', 'number', 'string'].includes(valueType);\n\treturn result;\n}\n\nfunction isScalar(value: JSONData): value is JSONScalar {\n\tconst result = value === null || ['boolean', 'number', 'string'].includes(typeof value);\n\treturn result;\n}\n\nfunction isJSONObject(value: JSONData): value is JSONObject {\n\tconst result = (typeof value === 'object') &&\n\t\t(value !== null) &&\n\t\t(!Array.isArray(value));\n\treturn result;\n}\n\nfunction isNumber(value: JSONData): value is number {\n\tconst result = (typeof value === 'number');\n\treturn result;\n}\n\nfunction isString(value: JSONData): value is string {\n\tconst result = (typeof value === 'string');\n\treturn result;\n}\n\n/** *************\n* Exact comparison functions\n** ************ */\n\nfunction numberCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (typeof target === 'number');\n\treturn result;\n}\n\nfunction stringCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (typeof target === 'string');\n\treturn result;\n}\n\nfunction booleanCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (typeof target === 'boolean');\n\treturn result;\n}\n\nfunction nullCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = (source === target) && (target === null);\n\treturn result;\n}\n\nfunction arrayCompare(source: JSONData, target: JSONData): boolean {\n\tconst result = Array.isArray(source) &&\n\tArray.isArray(target) &&\n\t(source.length === target.length) &&\n\ttarget.every((_, index) => compareValues(source[index], target[index]));\n\treturn result;\n}\n\nfunction compareValues(source: JSONData, target: JSONData): boolean {\n\tconst targetType = typeof target;\n\tlet result;\n\tif (target === null) {\n\t\tresult = nullCompare(source, target);\n\t}\n\tswitch (targetType) {\n\t\tcase 'boolean': result = booleanCompare(source, target as boolean); break;\n\t\tcase 'number': result = numberCompare(source, target as number); break;\n\t\tcase 'object': result = Array.isArray(target) ? arrayCompare(source, target as JSONData[]) : objectCompare(source as JSONObject, target as JSONObject); break;\n\t\tcase 'string': result = stringCompare(source, target as string); break;\n\t\tdefault: throw new Error(`Unsuported type ${targetType}`);\n\t}\n\treturn result;\n}\n\n/**\n * Function matches two objects, if those are the same.\n * Function does not do pattern matching, but exact comparison\n *\n * @param {JSONObject|null} source - object to test\n * @param {JSONObject|null} target - object to test agains\n * @returns { boolean } true if value is the same as target\n */\nfunction objectCompare(source: JSONObject | null, target: JSONObject | null): boolean {\n\tlet result = false;\n\tif (target === null) {\n\t\tresult = nullCompare(source, target);\n\t} else if (source === null) {\n\t\tresult = nullCompare(source, target);\n\t} else {\n\t\tconst keys = Object.keys(target);\n\t\tif (Object.keys(source).length === keys.length) {\n\t\t\tresult = keys.every((key: string) => compareValues(source[key], target[key]));\n\t\t}\n\t}\n\treturn result;\n}\n\n/** *************\n* types functions\n** ************ */\n\nfunction numberIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = numberCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction stringIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = stringCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction nullIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = nullCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction booleanIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = booleanCompare(value, template) ? template : undefined;\n\treturn result;\n}\n\nfunction scalarIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (template === null) {\n\t\tresult = nullIntersection(value, template);\n\t} else {\n\t\tconst templateType = typeof template;\n\t\tswitch (typeof template) {\n\t\t\tcase 'number': result = numberIntersection(value, template); break;\n\t\t\tcase 'string': result = stringIntersection(value, template); break;\n\t\t\tcase 'boolean': result = booleanIntersection(value, template); break;\n\t\t\tdefault: throw new Error(`Unsuported type ${templateType}`);\n\t\t}\n\t}\n\treturn result;\n\n}\n\nfunction arrayIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\t// const result = arrayCompare(value, template) ? template : undefined;\n\n\tconst result = Array.isArray(value) &&\n\tArray.isArray(template) &&\n\t(value.length === template.length) &&\n\ttemplate.every((_, index) => valueIntersection(value[index], template[index]));\n\treturn result ? template : undefined;\n}\n\n/**\n * Function provides recursive pattern matching.\n * If template is scalar, function just compares values\n * If template is array, function traverse the array and tries to apply all items as patterns to value\n * If template is object, function traverse the object and tries to apply all properties as patterns to value\n *\n * @param {JSONObject} source - object to test\n * @param {JSONObject} template - pattern to test agains\n * @returns { boolean } true if value matches template\n */\nfunction valueIntersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\n\t// scalar template\n\tif (isScalar(template)) {\n\t\tresult = scalarIntersection(value, template);\n\t} else if (Array.isArray(template)) { \t// array template\n\t\tresult = arrayIntersection(value, template);\n\t} else { // object template\n\t\tresult = objectTemplateIntersection(value, template);\n\t}\n\t// debugger;\n\treturn result;\n\n\t// throw new Error(`Unsuported type ${templateType}`);\n}\n\n/** *************\n* pattern functions\n** ************ */\n\n// equality - could be missing\nfunction $eq(value: JSONData, template: JSONData): Optional<JSONData> {\n\tconst result = valueIntersection(value, template);\n\t// debugger;\n\treturn result;\n}\n\n// negation\nfunction $not(value: JSONData, template: JSONData): Optional<JSONData> {\n\t// debugger;\n\tconst result = valueIntersection(value, template) === undefined ? template : undefined;\n\n\treturn result;\n}\n\n// value in template\nfunction $in(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$in expects array, ${template} given`);\n\t}\n\tconst found = template.find((_, index) => valueIntersection(value, template[index]));\n\treturn found !== undefined ? template : undefined;\n}\n\n// number of keys in object, number of items in array\nfunction $size(value: JSONData, template: JSONData): Optional<JSONData> {\n\t// if (!isNumber(template)) {\n\t// \tthrow new Error('$size parameter must be number');\n\t// }\n\t// if (Array.isArray(value)) {\n\t// \tif (value.length === template) {\n\t// \t\treturn template;\n\t// \t}\n\t// } else if (isJSONObject(value)) {\n\t// \tif (Object.keys(value).length === template) {\n\t// \t\treturn template;\n\t// \t}\n\t// } else {\n\t// \tthrow new Error('$size is applicable only for array and objects');\n\t// }\n\n\tlet size;\n\tif (Array.isArray(value)) {\n\t\tsize = value.length;\n\t} else if (isJSONObject(value)) {\n\t\tsize = Object.keys(value).length;\n\t}\n\tif (size !== undefined) {\n\t\tconst result = valueIntersection(size, template);\n\t\treturn result;\n\t}\n\n\treturn undefined;\n}\n\n// template in value\nfunction $contains(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(value)) {\n\t\tthrow new Error(`$contains expects array, ${value} given`);\n\t}\n\tconst found = value.find((_, index) => valueIntersection(value[index], template));\n\treturn found !== undefined ? template : undefined;\n}\n\n// arrays intersection\nfunction $intersection(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template) || !Array.isArray(value)) {\n\t\tthrow new Error(`$in expects array, ${template} , ${value} given`);\n\t}\n\tconst found = value.find((_, indexV) => template.find((__, index) => valueIntersection(value[indexV], template[index])));\n\n\treturn found !== undefined ? template : undefined;\n}\n\n// length arrays intersection - exact matching, no pattern matching\n// function $intersectionSize(value: JSONData, template: JSONData): Optional<JSONData> {\n// \tif (!Array.isArray(template) || !Array.isArray(value)) {\n// \t\tthrow new Error(`$in expects array, ${template} , ${value} given`);\n// \t}\n// \tconst found = value.map((_, indexV) => template.map((__, index) => compareValues(value[indexV], template[index])));\n// \tconsole.log(found);\n// \treturn found !== undefined ? template : undefined;\n// }\n\n// value is subset on template\nfunction $subsetOf(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template) || !Array.isArray(value)) {\n\t\tthrow new Error(`$in expects array, ${template} , ${value} given`);\n\t}\n\tconst found = value.every((_, indexV) => template.find((__, index) => valueIntersection(value[indexV], template[index])));\n\treturn found ? template : undefined;\n}\n\n// template is subset on value\nfunction $supersetOf(value: JSONData, template: JSONData): Optional<JSONData> {\n\n\tif (!Array.isArray(template) || !Array.isArray(value)) {\n\t\tthrow new Error(`$in expects array, ${template} , ${value} given`);\n\t}\n\n\t// const found = template.every((_, indexV) => value.find((__, index) => valueIntersection(value[index], template[indexV])));\n\tconst found = template.every((_, indexV) => {\n\t\tconst resultT = value.find((__, index) => {\n\t\t\tconst resultV = valueIntersection(value[index], template[indexV]);\n\t\t\treturn resultV !== undefined;\n\t\t});\n\t\treturn resultT !== undefined;\n\t});\n\treturn found ? template : undefined;\n}\n\nfunction canCompare(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (!isNumber(value) && !isString(value)) {\n\t\tresult = false;\n\t} else if (!isNumber(template) && !isString(template)) {\n\t\tresult = false;\n\t} else if (typeof value !== typeof template) {\n\t\tresult = false;\n\t} else {\n\t\tresult = true;\n\t}\n\n\treturn result;\n}\n\n// value is grater than template\nfunction $gt(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value > template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// value is grater or equal than template\nfunction $gte(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value >= template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// value is lower than template\nfunction $lt(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value < template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// value is lower or equal than template\nfunction $lte(value: JSONData, template: JSONData): Optional<JSONData> {\n\tlet result;\n\tif (canCompare(value, template)) {\n\t\t// @ts-ignore\n\t\tresult = value <= template;\n\t}\n\treturn result ? template : undefined;\n}\n\n// all items in template applies to value\nfunction $and(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$and template must be array, ${template} given`);\n\t}\n\n\tconst result = template.every((_, index) => valueIntersection(value, template[index]));\n\n\treturn result ? template : undefined;\n}\n\n// at least one items in template applies to value\nfunction $or(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$and template must be array, ${template} given`);\n\t}\n\n\tconst result = template.find((_, index) => valueIntersection(value, template[index]));\n\n\treturn result ? template : undefined;\n}\n\n// not any items in template applies to value\nfunction $none(value: JSONData, template: JSONData): Optional<JSONData> {\n\tif (!Array.isArray(template)) {\n\t\tthrow new Error(`$and template must be array, ${template} given`);\n\t}\n\n\tconst result = template.find((_, index) => valueIntersection(value, template[index]));\n\n\treturn result ? undefined : template;\n}\n\npatternFunctions.$eq = $eq; // any, any\npatternFunctions.$neq = $not; // any, any\npatternFunctions.$not = $not; // any, any\npatternFunctions.$in = $in; // any, array\npatternFunctions.$is = $eq; // any, any\npatternFunctions.$size = $size; // array | object, number\npatternFunctions.$contains = $contains; // array , any\npatternFunctions.$intersection = $intersection; // array , array\n// patternFunctions.$intersectionSize = $intersectionSize; // array , array\npatternFunctions.$subsetOf = $subsetOf; // array , array\npatternFunctions.$supersetOf = $supersetOf; // array , array\npatternFunctions.$gt = $gt; // string | number , string | number\npatternFunctions.$gte = $gte; // string | number , string | number\npatternFunctions.$lt = $lt; // string | number , string | number\npatternFunctions.$lte = $lte; // string | number , string | number\npatternFunctions.$and = $and; // any , array\npatternFunctions.$or = $or; // any , array\npatternFunctions.$none = $none; // any , array\n\nfunction patternIntersection(key: string, value: Optional<JSONData>, template: JSONData): Optional<JSONData> {\n\tlet result;\n\n\tif (key === '$exists') { // placeholder for $exists\n\t\tresult = (value === undefined) && (template === true);\n\t} else if (value === undefined) {\n\t\tthrow new Error(`Value cannot be undefined here for key: ${key}`); // this should never happen\n\t} else if (Object.hasOwn(patternFunctions, key)) {\n\t\tresult = patternFunctions[key].call(null, value, template);\n\t} else {\n\t\tthrow new Error(`Unsupported matching pattern ${key}`);\n\t}\n\n\t/* * /\n\tif (key === '$eq') key = '$is';\n\telse if (key === '$neq') key = '$not';\n\n\tswitch (key) {\n\t\tcase '$in': result = $in(value, template); break;\n\t\tcase '$is': result = $eq(value, template); break;\n\t\tcase '$not': result = $not(value, template); break;\n\t\tdefault: throw new Error(`Unsupported matching pattern ${key}`);\n\t}\n\t/* */\n\n\treturn result;\n}\n\nfunction objectTemplateIntersection(source: JSONData, template: JSONData): Optional<JSONObject> {\n\n\t// debugger;\n\tif (\n\t\t(typeof template !== 'object') ||\n\t\t(template === null) ||\n\t\t(Array.isArray(template)) ||\n\t\tfalse\n\t) {\n\t\tthrow new Error('Source and template must be non-null, non-array objects');\n\t}\n\n\tlet result = {} as JSONObject;\n\tconst templateKeys = Object.keys(template);\n\n\t// source && template are objects\n\tif (isJSONObject(source)) {\n\t\tconst allMatch = templateKeys.every((key: string) => {\n\t\t\tif (!supportedType(template[key])) {\n\t\t\t\tthrow new Error(`Unsupported value (type) in template ${template[key]}`);\n\t\t\t}\n\t\t\tif (Object.hasOwn(source, key)) {\n\t\t\t\tif (!supportedType(source[key])) {\n\t\t\t\t\tthrow new Error(`Unsupported value (type) in source ${source[key]}`);\n\t\t\t\t}\n\n\t\t\t\tconst match = valueIntersection(source[key], template[key]);\n\t\t\t\tif (match !== undefined) {\n\t\t\t\t\tresult[key] = match;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\telse if (key.startsWith('$')) {\n\n\t\t\t\t// let match;\n\t\t\t\t// ugly $size hack?? we must match object size agains whole object\n\t\t\t\t// if (['$size', '$eq', '$not', '$is', '$neq'].includes(key)) {\n\t\t\t\t// \tmatch = patternIntersection(key, source, template[key]);\n\t\t\t\t// } else {\n\t\t\t\t// \tmatch = patternIntersection(key, source[key], template[key]);\n\t\t\t\t// }\n\n\t\t\t\tconst match = patternIntersection(key, source, template[key]) || patternIntersection(key, source[key], template[key]);\n\n\t\t\t\tif (match !== undefined) {\n\t\t\t\t\tresult[key] = match;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} /* else {\n\t\t\t\tconst match = valueIntersection(undefined, template[key]);\n\n\t\t\t\tif (match !== undefined) {\n\t\t\t\t\tresult[key] = match;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} */\n\n\t\t\treturn false;\n\t\t});\n\t\tif (!allMatch) {\n\t\t\tresult = {};\n\t\t}\n\t} else { // source is scalar && template is object - all template keys must be patterns and all must match\n\n\t\tconst areMatching = templateKeys.every((key: string) => {\n\t\t\tif (key.startsWith('$')) {\n\t\t\t\tconst match = patternIntersection(key, source, template[key]);\n\t\t\t\tif (match !== undefined) {\n\t\t\t\t\tresult[key] = template[key];\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t});\n\t\tif (!areMatching) {\n\t\t\tresult = {};\n\t\t}\n\t}\n\n\treturn Object.keys(result).length > 0 ? result : undefined;\n}\n\n\nfunction objectIntersection(source: JSONData, template: JSONData): JSONObject | null {\n\t// debugger;\n\tif (\n\t\t(typeof source !== 'object') ||\n\t\t(typeof template !== 'object') ||\n\t\t(source === null) ||\n\t\t(template === null) ||\n\t\t(Array.isArray(source)) ||\n\t\t(Array.isArray(template)) ||\n\t\tfalse\n\t) {\n\t\tthrow new Error('Source and template must be non-null, non-array objects');\n\t}\n\tconst result = objectTemplateIntersection(source, template);\n\treturn result === undefined ? null : result;\n\n}\n\n/**\n * Main function for object matching\n *\n * @param {JSONObject} source - object to test\n * @param {JSONObject} template - pattern to test agains\n * @returns { boolean } true if value matches template\n */\nfunction objectMatch(source: JSONObject, template: JSONObject): boolean {\n\t// debugger;\n\treturn objectIntersection(source, template) !== null;\n}\n\nexport {\n\tJSONScalar, JSONObject, JSONData, JSONArray, Optional, PatternMatchingFunction,\n\tobjectIntersection, objectMatch, valueIntersection,\n\tobjectCompare,\n\n\tpatternFunctions,\n};\n"]}